package edu.academy;
import java.util.Scanner;
public class Main {

    public static void main(String[] args) {
        //все возможные побитовые операции с числами 42 и 15

        int a = 42, b = 15;

        System.out.println("в битах наши числа 42 и 15 равны " +
                Integer.toBinaryString(a) + " " + Integer.toBinaryString(b));
        System.out.println("----------------------");


        //побитовое и - если в равных позициях обеих чисел стоит 1
        int c = a & b;
        System.out.println("побитовое и = " + c + " или в битах равны " + Integer.toBinaryString(c)); //

        //побитовое или - если в равных позициях обеих чисел стоит хотя бы одна 1
        int d = a | b;
        System.out.println("побитовое или = " + d + " или в битах " + Integer.toBinaryString(d)); //

        //побитовое исключающее или - получаемое число в позиции получает единицу только если в этой позиции
        // у сравниваемых чисел только одна 1
        int e = a ^ b;
        System.out.println("побитовое исключающее или = " + e + " или в битах " + Integer.toBinaryString(e)); //

        //сдвиг с учетом знака - сдвиг операнда в сторону стрелок на количество знаков после сдвига >><<
        // при этом значения ушедшие из видимости пропадают а вновь появившиеся числа дополняются нулями
        // но старший (левый символ ставится тот, который был 1 или 0)
        int f = a >> 2;
        int g = b << 2;
        System.out.println("после сдвига числа 42 на 2 знака вправо получим " + f + " или в битах "
                + Integer.toBinaryString(f));
        System.out.println("после сдвига числа 15 на 2 знака влево получим " + g + " или в битах "
                + Integer.toBinaryString(g));

        //сдвиг без учета знака - сдвиг операнда вправо на количество знаков после сдвига >>>
        // при этом значения ушедшие из видимости пропадают а вновь появившиеся числа дополняются нулями
        //  старший (левый символ также заполняется 0)
        int h = a >>> 3;
        int h2 = b >>> 3;
        System.out.println("после сдвига числа 42 на 3 знака вправо без учета знака получим "
                + h + " или в битах " + Integer.toBinaryString(h));

        System.out.println("после сдвига числа 15 на 3 знака вправо без учета знака получим "
                + h2 + " или в битах " + Integer.toBinaryString(h2));
        //побитовое не - меняет значение символа в каждой позиции на противоположное
        int i = ~a;
        int j = ~b;
        System.out.println("не 42 равно " + i + " или в битах  " + Integer.toBinaryString(i));
        System.out.println("не 15 равно " + j + " или в битах  " + Integer.toBinaryString(j));


        System.out.println("----------------------------");
        System.out.println();

        ///дальше все тоже самое с числами (-42) и (-15)
        //////////////////////

        int aa = -42, bb = -15;

        System.out.println(" вторая часть - в битах наши числа -42 и -15 равны " +
                Integer.toBinaryString(aa) + " " + Integer.toBinaryString(bb));
        System.out.println("----------------------");


        //побитовое и - если в равных позициях обеих чисел стоит 1
        int cc = aa & bb;
        System.out.println("побитовое и = " + cc + " или в битах равны " + Integer.toBinaryString(cc)); //

        //побитовое или - если в равных позициях обеих чисел стоит хотя бы одна 1
        int dd = aa | bb;
        System.out.println("побитовое или = " + dd + " или в битах " + Integer.toBinaryString(dd)); //

        //побитовое исключающее или - получаемое число в позиции получает единицу только если в этой позиции
        // у сравниваемых чисел только одна 1
        int ee = aa ^ bb;
        System.out.println("побитовое исключающее или = " + ee + " или в битах " + Integer.toBinaryString(ee)); //

        //сдвиг с учетом знака - сдвиг операнда в сторону стрелок на количество знаков после сдвига >><<
        // при этом значения ушедшие из видимости пропадают а вновь появившиеся числа дополняются нулями
        // но старший (левый символ ставится тот, который был 1 или 0)
        int ff = aa >> 2;
        int gg = bb << 2;
        System.out.println("после сдвига числа -42 на 2 знака вправо получим " + ff + " или в битах "
                + Integer.toBinaryString(ff));
        System.out.println("после сдвига числа -15 на 2 знака влево получим " + gg + " или в битах "
                + Integer.toBinaryString(gg));

        //сдвиг без учета знака - сдвиг операнда вправо на количество знаков после сдвига >>>
        // при этом значения ушедшие из видимости пропадают а вновь появившиеся числа дополняются нулями
        //  старший (левый символ также заполняется 0)
        int hh = aa >>> 3;
        int hhh = bb >>> 3;
        System.out.println("после сдвига числа -42 на 3 знака вправо без учета знака получим "
                + hh + " или в битах " + Integer.toBinaryString(hh));
        System.out.println("после сдвига числа -15 на 3 знака вправо без учета знака получим "
                + hhh + " или в битах " + Integer.toBinaryString(hhh));

        //побитовое не - меняет значение символа в каждой позиции на противоположное
        int ii = ~aa;
        int jj = ~bb;
        System.out.println("не (-42) равно " + ii + " или в битах  " + Integer.toBinaryString(ii));
        System.out.println("не (-15) равно " + jj + " или в битах  " + Integer.toBinaryString(jj));

        //////////////
        System.out.println("----------------------------");
        System.out.println();

        System.out.println("Третья часть - про приоритетность при операциях");
        int s1 = 5 + 2 / 8; /// сразу делается деление - 2/8 =0,25. но так как тип инт - дробная часть отбрасывается.
        //затем 5+0 = 5
        System.out.println("первый пример " + s1);

        int s2 = (5 + 2) / 8; // сразу скобки, они в самом верху приоритета = 7. 7/8 =  получается 0,9... в инт
        //дробная часть отбрасывается. в итоге 0;
        System.out.println("второй пример " + s2);

        int s33 = 2;
        int s3 = (5 + s33++) / 8; //сразу скобки - в них постфикс поэтому 5+2=7. 7/8 = 0,9. s3 отбрасывает дробную часть
        //поэтому 0.
        System.out.println("третий пример " + s3);

        int s41 = 2;
        int s42 = 8;
        int s4 = (5 + s41++) / --s42; //ответ 1.сразу скобки - в них постфикс сработает после выполнения всей строки
        //поэтому в скобках 7. дальше префикс декремента -- (будет значение 7). и деление в конце - 7/7=1
        System.out.println("четвертый пример " + s4);

        int s51 = 2, s52 = 8;
        int s5 = (5 * 2 >> s51++) / --s52; //сразу скобки, сдвиг стоит ниже умножения. сразу умножаем 5*2 =10.
        // сдвиг числа 10 на 2 знака влево дает число 2. итого в скобках у нас 2. дальше префиксный декремент дает 7.
        //дальше 2/7 = 0,285. integer покажет 0.
        int s53 = 10 >> 2;
        System.out.println("пятый пример " + s5);
        System.out.println("ради интереса - сдвиг 10 на 2 знака вправо даст число " + s53);

        int s61 = 2;
        int s62 = 8;
        int s6 = (5 + 7 > 20 ? 68 : 22 * 2 >> s61++) / --s62; // умножение важнее сдвига.22*2 = 44. 44 по сдвигу вправо на 2 даст 11.
        // дальше действие в скобках (12>20 = false ? 68: 11) - принимаем 11 т.к. фолс. дальше 11 делим на 7(
        // сработал префикс) = 1,57. интегер округлит до 1.
        System.out.println("шестой пример " + s6);

        // int s7 = (5 + 7 > 20 ? s73 : 22 * 2 >> s71++) / --s72;

        boolean s8 = 6 - 2 > 3 && 12 * 12 <= 119;//сразу умножение 12 *12 = 144 - false. слева от знака && тру.
        // для того чтобы переменная была true толжны выполняться оба условия. итог - false
        System.out.println("решение восьмого " + s8);

        boolean s9 = true && false; // false должны быть оба тру для булевой тру
        System.out.println("девятый пример " + s9);

        //////////////////////////
        System.out.println("-------------------");
        System.out.println("четверный блок про имена");

        Scanner in = new Scanner(System.in);
        System.out.println("введите имя пользователя");
        String name = in.nextLine();

        //решение через if
        if (name == "Вася") {
            System.out.println("Привет! \n я так долго тебя ждала");
        } else {
            if (name == "Анастасия") {
                System.out.println("Я тебя так долго ждал");
            } else
                System.out.println("Добрый день, а вы кто?");
        }


        //решение через if..else
        if (name == "Вася") {
            System.out.println("Привет! \n я так долго тебя ждал");
        } else if (name == "Анастасия") {
            System.out.println("Я тебя так долго ждал");
        } else {
            System.out.println("Добрый день, а вы кто?");
        }

        //решение через switch
        switch (name){
            case ("Вася"):
                System.out.println("Привет! \n я так долго тебя ждал");
                break;
            case ("Анастасия"):
                System.out.println("Я тебя так долго ждал");
                break;
            default:
                System.out.println("Добрый день, а вы кто?");
                break;
        }
    }
}